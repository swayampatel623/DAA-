import java.util.Scanner;
public class DA_FloydWarshall
{
final static int INF = 99999;
// Infinity (used to represent no path) 
public static void floydWarshall(int[][] graph, int n)
{
int[][] dist = new int[n][n];
// Initialize the solution matrix same as input graph matrix 
for (int i = 0; i < n; i++) 
{
for (int j = 0; j < n; j++)
{
dist[i][j] = graph[i][j];
}
}
// Dynamic programming approach 
for (int k = 0; k < n; k++) 
{
for (int i = 0; i < n; i++) 
{ 
for (int j = 0; j < n; j++) 
{
if (dist[i][k] + dist[k][j] < dist[i][j])
{
dist[i][j] = dist[i][k] + dist[k][j];
}
}
}
}
printSolution(dist, n);
}
public static void printSolution(int[][] dist, int n) 
{
System.out.println("Shortest distances between every pair of vertices:"); 
for (int i = 0; i < n; i++) 
{
for (int j = 0; j < n; j++) 
{ 
if (dist[i][j] == INF) 
{

System.out.print("INF ");
} 
else
{
System.out.print(dist[i][j] + " ");
}
}
System.out.println();
}
}
public static void main(String[] args)
{ 
Scanner scanner = new Scanner(System.in);
System.out.print("Enter the number of vertices: ");
int n = scanner.nextInt();
int[][] graph = new int[n][n];
System.out.println("Enter the adjacency matrix (enter 99999 for no direct path):");
for (int i = 0; i < n; i++)
{
for (int j = 0; j < n; j++)
{ 
graph[i][j] = scanner.nextInt();
}
}
floydWarshall(graph, n); 
scanner.close();
}
}
